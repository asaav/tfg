We now needed to make a choice between the previous algorithms. Although the final software doesn’t really need to be in real time, we want to make it as fast as possible while sacrificing as less effectiveness as possible. Because of that, we made an analysis of performance of all these algorithms, where MOG2, CNT and KNN were the best performance-wise. CNT was discarded due to its inconsistency in detection and its difficulty to detect shadows properly. Between the last two, MOG2 was the selected because it generated better backgrounds models. 
After applying the background subtraction algorithm selected, we needed to perform some additional procedures to improve the results achieved using it. One of them is assigning every contour an ID number that identifies them both visually and in the CSV file generated after running the program. To make these assignments, we used a mutual matching algorithm between contours of a frame to those of the former.
Another of those procedures is non-maximum suppression, which consists in detecting overlapping contours and finding a maximum enclosure for them. This way, the detection of every contour is cleaner. A side effect to this operation is that, when two players overlap, the rectangles that identify them will also overlap, so they will join in a single rectangle until they separate. Therefore, our overlapping resolution policy will be to assign a new ID to the maximum rectangle which encloses both players and when they separate, assume they are two new contours. This is because determining which previous ID belongs to which player is very difficult, even if we use their paths, it is possible that a player changes direction after overlapping with another.
As stated before, we need to make the ball detection especially consistent, but to the eyes of our background subtractor, contours have no special distinction between them. To distinguish the ball apart from the players, we need a circularity test based in the shape of that contour. The roundest element of the scene must be the ball.
When implementing tracking algorithms, at the beginning we tested the ones included in the collaborative module of OpenCV, but they were all too slow and were discarded in favour of Mean Shift and Camshift. 
Both methods are roughly the same. The difference is that Camshift adapts the tracking window to the object that it is following. Apart from that, both methods store a histogram of the first tracking window provided and, from that point on, calculate back projections of the image over that histogram thus getting a probability map and then calculating the centroid of the points near the window until the algorithm converges. Between these two algorithms, we chose Mean Shift over Camshift because we don’t need our algorithm to adapt to shapes because they will always have the same size since their distances to the camera will be the same most of the time.

We still had to solve ball detection consistency. Until this point, we used a shape test over all the scene, which led the algorithm to momentarily mark players as ball when they were perpendicular to the camera and we also sometimes lost track of the ball, giving it a new ID. This could be solved by considering the ball’s last position, using temporal consistency. 
To implement this, first we needed to make the software able to detect plays, which we did manually as it is hard to determine when a play ends automatically without having a clear reference of the distance between the ball and the floor. Once we run the software once marking all the plays we want, we can run it again passing the log file generated with the data of said plays. Applying a group of heuristics, like distance from the last frame to the next, circularity value and taking into account the ID that was consecutively identified as ball more frames, we can take our software from a 22% of ball detection to 78% in the frames of a single play, which is a great improvement considering the ball doesn’t appear in every frame due to overlaps.
All things considered, this project concluded with a high level of accomplishment of the objectives we set ourselves. We developed a system that uses both background subtraction and tracking to detect the players of the scene. For ball detection, we used circularity test as well as temporal consistency using some heuristics. The final software has two interface options, one uses command line parameters and the other is a graphical user interface developed in PyQt with the intent of providing a friendlier user experience to some people.
Some ways that we could improve this project are implementing automatic play detection, extending the temporal consistency model to include also players, using other models like Hidden Markov Models, Kalman filters or Viterbi algorithm and solving the overlapping problems giving players their previous ID number. We also could consider parameter auto-tuning as a way to improve the application
